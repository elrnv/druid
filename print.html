<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Druid</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="expanded "><a href="setup.html"><strong aria-hidden="true">2.</strong> Set up Druid</a></li><li class="expanded "><a href="get_started.html"><strong aria-hidden="true">3.</strong> Get started with Druid</a></li><li class="expanded "><a href="data.html"><strong aria-hidden="true">4.</strong> Data trait</a></li><li class="expanded "><a href="widget.html"><strong aria-hidden="true">5.</strong> Widget trait</a></li><li class="expanded "><a href="lens.html"><strong aria-hidden="true">6.</strong> Lens trait</a></li><li class="expanded "><a href="env.html"><strong aria-hidden="true">7.</strong> Env</a></li><li class="expanded "><a href="localization.html"><strong aria-hidden="true">8.</strong> Localization (TODO)</a></li><li class="expanded "><a href="command.html"><strong aria-hidden="true">9.</strong> Command (TODO)</a></li><li class="expanded "><a href="custom_widgets.html"><strong aria-hidden="true">10.</strong> Widgets in depth (TODO)</a></li><li class="expanded "><a href="example_demos.html"><strong aria-hidden="true">11.</strong> Example Demos</a></li><li class="spacer"></li><li class="expanded "><a href="more_information.html"><strong aria-hidden="true">12.</strong> More information</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Druid</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#druid" id="druid">Druid</a></h1>
<p>Druid is a framework for building simple graphical applications.</p>
<p>'Druid' is composed of a number of related projects. <a href="https://docs.rs/druid-shell"><code>druid-shell</code></a> is a
low-level library that provides a common abstraction for interacting with the
current OS &amp; window manager. <a href="https://docs.rs/piet"><code>piet</code></a> is an abstraction for doing 2D graphics;
<a href="https://docs.rs/kurbo"><code>kurbo</code></a> is a library for 2D geometry; and <a href="https://docs.rs/druid"><code>druid</code></a> itself is an opinionated set of
high-level APIs for building cross-platform desktop applications.</p>
<p>Druid is <em>data oriented</em>. It shares many ideas (and is directly inspired by)
contemporary declarative UI frameworks such as <a href="https://flutter.dev">Flutter</a>, <a href="https://developer.android.com/jetpack/compose">Jetpack Compose</a>,
and <a href="https://developer.apple.com/documentation/swiftui">SwiftUI</a>, while also attempting to be conceptually simple and largely
<em>non-magical</em>. A programmer familiar with Rust should be able to understand how
druid works without special difficulty.</p>
<h2><a class="header" href="#goals-and-status" id="goals-and-status">Goals and Status</a></h2>
<p>The current goal of druid is to make it easy to write a program in Rust that
can present a GUI and accept user input. Running your program should be as
simple as <code>cargo run</code>.</p>
<h2><a class="header" href="#key-concepts" id="key-concepts">Key Concepts</a></h2>
<ul>
<li><strong><a href="./data.html">the <code>Data</code> trait</a></strong>: How you represent your application model.</li>
<li><strong><a href="./widget.html">the <code>Widget</code> trait</a></strong>: How you represent your UI.</li>
<li><strong><a href="./lens.html">the <code>Lens</code> trait</a></strong>: How you associate parts of your model with parts of
your UI.</li>
</ul>
<h1><a class="header" href="#set-up-druid" id="set-up-druid">Set up Druid</a></h1>
<p>This tutorial assumes basic familliarity with Rust and a working setup with the basic tooling like
Rustup and Cargo. This tutorial will use stable Rust (v1.39.0 at the time of writing) and the latest
released version of Druid.</p>
<p>This tutorial will first walk you through setting up the dependencies for developing a Druid
application, then it will show you how to set up a basic application, build it and run it.</p>
<h2><a class="header" href="#setting-up-druid-dependencies" id="setting-up-druid-dependencies">Setting up Druid dependencies</a></h2>
<p>In addition to including the druid library in your project</p>
<h3><a class="header" href="#macos" id="macos">macOS</a></h3>
<p>On macOS, druid requires <a href="https://www.cairographics.org">cairo</a>; if you use homebrew, <code>brew install cairo</code>
should be sufficient. Removing this dependency is on the roadmap.</p>
<h3><a class="header" href="#linux" id="linux">Linux</a></h3>
<p>On Linux, druid requires gtk+3.</p>
<p>On Ubuntu this can be installed with</p>
<pre><code class="language-no_compile">sudo apt-get install libgtk-3-dev
</code></pre>
<p>On Fedora</p>
<pre><code class="language-no_compile">sudo dnf install gtk3-devel glib2-devel
</code></pre>
<p>See <a href="http://gtk-rs.org/docs/requirements.html">gtk-rs dependencies</a> for more installation instructions.</p>
<h2><a class="header" href="#starting-a-project" id="starting-a-project">Starting a project</a></h2>
<p>Starting a project is as easy as creating an empty application with</p>
<pre><code class="language-no_compile">cargo new my-application
</code></pre>
<p>and adding the druid dependency to your Cargo.toml</p>
<pre><code class="language-no_compile">[dependencies]
druid = &quot;0.5.0&quot;
// or:
druid = { git = &quot;https://github.com/xi-editor/druid.git&quot;, branch = &quot;master&quot; }
</code></pre>
<h1><a class="header" href="#get-started-with-druid" id="get-started-with-druid">Get started with Druid</a></h1>
<p><em>this is outdated, and should be replaced with a walkthrough of getting a simple
app built and running</em>.</p>
<p>This chapter will walk you through setting up a simple druid application from start to finish.</p>
<h2><a class="header" href="#set-up-a-druid-project" id="set-up-a-druid-project">Set up a Druid project</a></h2>
<p>Setting up a project is a simple as creating a new Rust project;</p>
<pre><code class="language-bash">&gt; cargo new druid-example
</code></pre>
<p>And then adding druid as a dependency to Cargo.toml</p>
<pre><code class="language-toml">[dependencies]
druid = &quot;0.5.0&quot;
</code></pre>
<p>To show a minimal window with a label replace <code>main.rs</code> with this;</p>
<pre><code class="language-rust noplaypen">use druid::{AppLauncher, WindowDesc, Widget, PlatformError};
use druid::widget::Label;

fn build_ui() -&gt; impl Widget&lt;()&gt; {
    Label::new(&quot;Hello world&quot;)
}

fn main() -&gt; Result&lt;(), PlatformError&gt; {
    AppLauncher::with_window(WindowDesc::new(build_ui)).launch(())?;
    Ok(())
}
</code></pre>
<p>In our main function we create an <code>AppLauncher</code>, pass it a <code>WindowDesc</code> that wraps build_ui function and launch it. Druid will use our <code>build_ui</code> function to build and rebuild our main window every time it needs to refresh. <code>build_ui</code> returns a tree of widgets. For now this tree consists of one simple label widget.</p>
<p>This is a very simple example application and it's missing some important pieces. We will add these in the coming few paragraphs.</p>
<h2><a class="header" href="#draw-more-widgets" id="draw-more-widgets">Draw more widgets</a></h2>
<p>The first thing we could do to make our example application more interesting is to draw more than one widget. Unfortunately <code>WindowDesc::new</code> expects a function that returns only one Widget. We also need a way to tell Druid how to lay-out our widgets.
We solve both these problems by passing in a widget-tree with one single widget at the top. Widgets can have children and widgets higher up in the tree know how to lay-out their children. That way we describe a window as a widget-tree with layout containers as the branches and widgets as the leaves. Our <code>build_ui</code> function is then responsible for building this widget tree.</p>
<p>To see how this works we will divide our window in four. We'll have two rows and two columns with a single label in each of the quadrants. We can lay-out our labels using the <code>Flex</code> widget.</p>
<pre><code class="language-rust noplaypen">fn build_ui() -&gt; impl Widget&lt;()&gt; {
    Flex::row()
        .with_flex_child(
            Flex::column()
                .with_flex_child(Label::new(&quot;top left&quot;), 1.0)
                .with_flex_child(Label::new(&quot;bottom left&quot;), 1.0),
            1.0)
        .with_flex_child(
            Flex::column()
                .with_flex_child(Label::new(&quot;top right&quot;), 1.0)
                .with_flex_child(Label::new(&quot;bottom right&quot;), 1.0),
            1.0)
}
</code></pre>
<p>This looks nice but the labels on the left are drawn right against the window edge, so we needs some padding. Lets say we also want to center the two bottom labels. Unlike many other UI frameworks, widgets in Druid don't have padding or alignment properties themselves. Widgets are kept as simple as possible.</p>
<p>Features like padding or alignment are implemented in separate widgets. To add padding you simply wrap the labels in a <code>Padding</code> widget. Centering widgets is done using the <code>Align</code> widget set to <code>centered</code>.</p>
<pre><code class="language-rust noplaypen">fn build_ui() -&gt; impl Widget&lt;()&gt; {
    Padding::new(
        10.0,
        Flex::row()
            .with_flex_child(
                Flex::column()
                    .with_flex_child(Label::new(&quot;top left&quot;), 1.0)
                    .with_flex_child(Align::centered(Label::new(&quot;bottom left&quot;)), 1.0),
                1.0)
            .with_child(
                Flex::column()
                    .with_flex_child(Label::new(&quot;top right&quot;), 1.0)
                    .with_flex_child(Align::centered(Label::new(&quot;bottom right&quot;)), 1.0),
                1.0))
}
</code></pre>
<p>Do not forget to import the new widgets;</p>
<pre><code class="language-rust noplaypen">use druid::widget::{Label, Flex, Padding, Align};
</code></pre>
<h2><a class="header" href="#application-state" id="application-state">Application state</a></h2>
<p>We can display a window and draw and position widgets in it. Now it's time to find out how we can tie these widgets to
the rest of our application. First lets see how we can display information from our application in the user interface.
For this we need to define what our application's state looks like.</p>
<p>...</p>
<h2><a class="header" href="#handle-user-input" id="handle-user-input">Handle user input</a></h2>
<p>...</p>
<h2><a class="header" href="#putting-it-all-together" id="putting-it-all-together">Putting it all together</a></h2>
<p>...</p>
<h1><a class="header" href="#model-data-and-the-data-trait" id="model-data-and-the-data-trait">Model data and the <code>Data</code> trait</a></h1>
<p>The heart of a <code>druid</code> application is your application model. Your model drives
your UI. When you mutate your model, druid compares the old and new version,
and propagates the change to the components ('widgets') of your application that
are affected by the change.</p>
<p>For this to work, your model must implement the <code>Clone</code> and <code>Data</code> traits. It
is important that your model be cheap to clone; we encourage the use of
reference counted pointers to allow cheap cloning of more expensive types. <code>Arc</code>
and <code>Rc</code> have blanket <code>Data</code> impls, so if you have a type that does not
implement <code>Data</code>, you can always just wrap it in one of those smart pointers.</p>
<p>The <code>Data</code> trait has a single method:</p>
<pre><code class="language-rust no_run noplaypen">    /// Determine whether two values are the same.
    ///
    /// This is intended to always be a fast operation. If it returns
    /// `true`, the two values *must* be equal, but two equal values
    /// need not be considered the same here, as will often be the
    /// case when two copies are separately allocated.
    ///
    /// Note that &quot;equal&quot; above has a slightly different meaning than
    /// `PartialEq`, for example two floating point NaN values should
    /// be considered equal when they have the same bit representation.
    fn same(&amp;self, other: &amp;Self) -&gt; bool;
</code></pre>
<h4><a class="header" href="#derive" id="derive">Derive</a></h4>
<p><code>Data</code> can be derived. This is recursive; it requires <code>Data</code> to be implemented
for all members. For 'C style' enums (enums where no variant has any fields)
this also requires an implementation of <code>PartialEq</code>. <code>Data</code> is implemented for
a number of <code>std</code> types, including all primitive types, <code>String</code>, <code>Arc</code>, <code>Rc</code>,
as well as <code>Option</code>, <code>Result</code>, and various tuples whose members implement
<code>Data</code>.</p>
<p>Here is an example of using <code>Data</code> to implement a simple data model.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use druid::Data;
use std::sync::Arc;

#[derive(Clone, Data)]
/// The main model for a todo list application.
struct TodoList {
    items: Arc&lt;Vec&lt;TodoItem&gt;&gt;,
}

#[derive(Clone, Data)]
/// A single todo item.
struct TodoItem {
    category: Category,
    // `Data` is implemented for any `Arc`.
    due_date: Option&lt;Arc&lt;DateTime&gt;&gt;,
    // you can specify a custom comparison fn
    // (anything with the signature (&amp;T, &amp;T) -&gt; bool)
    #[data(same_fn = &quot;PartialEq::eq&quot;)]
    added_date: DateTime,
    title: String,
    note: Option&lt;String&gt;,
    completed: bool,
}

#[derive(Clone, Data, PartialEq)]
/// The three types of tasks in the world.
enum Category {
    Work,
    Play,
    Revolution,
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#widgets-and-the-widget-trait" id="widgets-and-the-widget-trait">Widgets and the <code>Widget</code> trait</a></h1>
<p>The <code>Widget</code> trait represents components of your UI. Druid includes a set of
built-in widgets, and you can also write your own. You combine the built-in
and custom widgets to create a <em>widget tree</em>; you will start with some single
<em>root widget</em>, which will (generally) have children, which may themselves have
children, and so on. <code>Widget</code> has a generic parameter <code>T</code> that represents
the <a href="./data.html"><code>Data</code></a> handled by that widget. Some widgets (such as layout widgets)
may be entirely agnostic about what sort of <code>Data</code> they encounter, while other
widgets (such as a slider) may expect a single type (such as <code>f64</code>).</p>
<blockquote>
<p><strong>Note</strong>: For more information on how different parts of your <a href="./data.html"><code>Data</code></a> are exposed
to different widgets, see <a href="./lens.html"><code>Lens</code></a>.</p>
</blockquote>
<p>At a high level, druid works like this:</p>
<ul>
<li><strong>event</strong>: an <code>Event</code> arrives from the operating system, such as a key press,
a mouse movement, or a timer firing. This event is delivered to your root
widget's <code>event</code> method. This method is provided <strong>mutable</strong> access to your
application model; this is the only place where your model can change. Depending
on the type of <code>Event</code> and the implementation of your <code>event</code> method, this
event is then delivered recursively down the tree until it is handled.</li>
<li><strong>update</strong>: After this call returns, the framework checks to see if the data was mutated.
If so, it calls your root widget's <code>update</code> method, passing in both the new
data as well as the previous data. Your widget can then update any internal
state (data that the widget uses that is not part of the application model,
such as appearance data) and can request a <code>layout</code> or a <code>paint</code> call if
its appearance is no longer valid.</li>
<li>After <code>update</code> returns, the framework checks to see if any widgets in a
given window have indicated that they need layout or paint. If so, the
framework will call the following methods:</li>
<li><strong>layout</strong>: This is where the framework determines where to position each
widget on the screen. Druid uses a layout system heavily inspired by Flutter's
<a href="https://api.flutter.dev/flutter/rendering/BoxConstraints-class.html">box layout model</a>: widgets are passed constraints, in the form of a minimum
and a maximum allowed size, and they return a size in that range.</li>
<li><strong>paint</strong>: After <code>layout</code>, the framework calls your widget's <code>paint</code> method.
This is where your widget draws itself, using a familiar imperative 2D graphics
API.</li>
<li>In addition to these four methods, there is also <strong>lifecycle</strong>, which is
called in response to various changes to framework state; it is not called
predictably during event handling, but only when extra information (such
as if a widget has gained focus) happens as a consequence of other events.</li>
</ul>
<p>For more information on implementing these methods, see <a href="./custom_widgets.html">Creating custom
widgets</a>.</p>
<h2><a class="header" href="#modularity-and-composition" id="modularity-and-composition">Modularity and composition</a></h2>
<p>Widgets are intended to be modular and composable, not monolithic. For instance,
widgets generally do not control their own alignment or padding; if you have
a label, and you would like it to have 8px of horizontal padding and 4px of
vertical padding, you can just do,</p>
<pre><code class="language-rust noplaypen">use druid::widget::{Label, Padding};

fn padded_label() {
    let label: Label&lt;()&gt; = Label::new(&quot;Humour me&quot;);
    let padded = Padding::new((4.0, 8.0), label);
}
</code></pre>
<p>to force the label to be center-aligned if it is given extra space you can write,</p>
<pre><code class="language-rust noplaypen">use druid::widget::Align;

fn align_center() {
    let label: Label&lt;()&gt; = Label::new(&quot;Center me&quot;);
    let centered = Align::centered(label);
}
</code></pre>
<h2><a class="header" href="#builder-methods-and-widgetext" id="builder-methods-and-widgetext">Builder methods and <code>WidgetExt</code></a></h2>
<p>Widgets are generally constructed using builder-style methods. Unlike the normal
<a href="https://doc.rust-lang.org/1.0.0/style/ownership/builders.html">builder pattern</a>, we generally do not separate the type that is
built from the builder type; instead the builder methods are on the widget
itself.</p>
<pre><code class="language-rust noplaypen">use druid::widget::Stepper;

fn steppers() {
    // A Stepper with default parameters
    let stepper1 = Stepper::new();

    // A Stepper that operates over a custom range
    let stepper2 = Stepper::new().with_range(10.0, 50.0);

    // A Stepper with a custom range *and* a custom step size, that
    // wraps around past its min and max values:
    let stepper3 = Stepper::new()
        .with_range(10.0, 50.0)
        .with_step(2.5)
        .with_wraparound(true);
}
</code></pre>
<p>Additionally, there are a large number of helper methods available on all
widgets, as part of the <code>WidgetExt</code> trait. These builder-style methods take one
widget and wrap it in another. The following two functions produce the same
output:</p>
<p><strong>Explicit</strong>:</p>
<pre><code class="language-rust noplaypen">use druid::widget::{Align, Padding, Stepper};

fn padded_stepper() {
    let stepper = Stepper::new().with_range(10.0, 50.0);
    let padding = Padding::new(8.0, stepper);
    let padded_and_center_aligned_stepper = Align::centered(padding);
}
</code></pre>
<p><strong>WidgetExt</strong>:</p>
<pre><code class="language-rust noplaypen">use druid::widget::{Stepper, WidgetExt};

fn padded_stepper() {
    let padded_and_center_aligned_stepper =
        Stepper::new().with_range(10.0, 50.0).padding(8.0).center();
}
</code></pre>
<p>These builder-style methods also exist on containers. For instance, to create
a stack of three labels, you can do:</p>
<pre><code class="language-rust noplaypen">use druid::widget::Flex;

fn flex_builder() -&gt; Flex&lt;()&gt; {
    Flex::column()
        .with_child(Label::new(&quot;Number One&quot;))
        .with_child(Label::new(&quot;Number Two&quot;))
        .with_child(Label::new(&quot;Some Other Number&quot;))
}
</code></pre>
<h1><a class="header" href="#lenses-and-the-lens-trait" id="lenses-and-the-lens-trait">Lenses and the <code>Lens</code> trait</a></h1>
<p>Let's say we're building a todo list application, and we are designing the widget
that will represent a single todo item. Our data model looks like this:</p>
<pre><code class="language-rust noplaypen">/// A single todo item.
#[derive(Clone, Data)]
struct TodoItem {
    title: String,
    completed: bool,
    urgent: bool,
}
</code></pre>
<p>We would like our widget to display the title of the item, and then below
that to display two checkmarks that toggle the 'completed' and 'urgent' bools.
<code>Checkbox</code> (a widget included in druid) implements <code>Widget&lt;bool&gt;</code>.
How do we use it with <code>TodoItem</code>? By using a <code>Lens</code>.</p>
<h2><a class="header" href="#conceptual" id="conceptual">Conceptual</a></h2>
<p>You can think of a lens as a way of &quot;focusing in&quot; on one part of the data. You
have a <code>TodoItem</code>, but you <em>want</em> a <code>bool</code>.</p>
<p><code>Lens</code> is a trait for types that perform this &quot;focusing in&quot; (aka <em>lensing</em>).
A simplified version of the <code>Lens</code> trait might look like this:</p>
<pre><code class="language-rust noplaypen">trait SimpleLens&lt;In, Out&gt; {
    fn focus(&amp;self, data: &amp;In) -&gt; Out;
}
</code></pre>
<p>That is, this type takes an instance of <code>In</code>, and returns an instance of <code>Out</code>.</p>
<p>For instance, imagine we wanted a lens to focus onto the <code>completed</code> state of
our <code>TodoItem</code>. With our simple trait, we might do:</p>
<pre><code class="language-rust noplaypen">/// This is the type of the lens itself; in this case it has no state.
struct CompletedLens;

impl SimpleLens&lt;TodoItem, bool&gt; for CompletedLens {
    fn focus(&amp;self, data: &amp;TodoItem) -&gt; bool {
        data.completed
    }
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: <code>Lens</code> isn't that helpful on its own; in druid it is generally used alongside
<code>LensWrap</code>, which is a special widget that uses a <code>Lens</code> to change the <code>Data</code>
type of its child. Lets say we have a <code>Checkbox</code>, but our data is a <code>TodoItem</code>:
we can do, <code>LensWrap::new(my_checkbox, CompletedLens)</code> in order to bridge the
gap.</p>
</blockquote>
<p>Our example is missing out on an important feature of lenses, though, which is that
they allow mutations that occur on the <em>lensed</em> data to propagate back to the
source. For this to work, lenses actually work with closures. The real signature
of <code>Lens</code> looks more like this (names changed for clarity):</p>
<pre><code class="language-rust noplaypen">pub trait Lens&lt;In, Out&gt; {
    /// Get non-mut access to the field.
    fn with&lt;R, F: FnOnce(&amp;Out) -&gt; R&gt;(&amp;self, data: &amp;In, f: F) -&gt; R;
    /// Get mut access to the field.
    fn with_mut&lt;R, F: FnOnce(&amp;mut Out) -&gt; R&gt;(&amp;self, data: &amp;mut In, f: F) -&gt; R;
}
</code></pre>
<p>Here <code>In</code> refers to the input to the <code>Lens</code> and <code>Out</code> is the output. <code>F</code> is a
closure that can return a result, <code>R</code>.</p>
<p>Now, instead of just being passed <code>Out</code> directly from the function, we pass the
function a closure that will <em>itself</em> be passed an <code>Out</code>; if our closure returns
a result, that will be given back to us.</p>
<p>This is unnecessary in the case of non-mutable access, but it is important for
mutable access, because in many circumstances (such as when using an <code>Rc</code> or
<code>Arc</code>) accessing a field mutably is expensive even if you don't do any mutation.</p>
<p>In any case, the real implementation of our lens would look like,</p>
<pre><code class="language-rust noplaypen">struct CompletedLens;

impl Lens&lt;TodoItem, bool&gt; for CompletedLens {
    fn with&lt;R, F: FnOnce(&amp;bool) -&gt; R&gt;(&amp;self, data: &amp;TodoItem, f: F) -&gt; R {
        f(&amp;data.completed)
    }

    fn with_mut&lt;R, F: FnOnce(&amp;mut bool) -&gt; R&gt;(&amp;self, data: &amp;mut TodoItem, f: F) -&gt; R {
        f(&amp;mut data.completed)
    }
}
</code></pre>
<p>That seems pretty simple and fairly annoying to write, which is why you
generally don't have to.</p>
<h2><a class="header" href="#deriving-lenses" id="deriving-lenses">Deriving lenses</a></h2>
<p>For simple field access, you can <code>derive</code> the <code>Lens</code> trait.</p>
<pre><code class="language-rust noplaypen">/// A single todo item.
#[derive(Clone, Data, Lens)]
struct TodoItem {
    title: String,
    completed: bool,
    urgent: bool,
}
</code></pre>
<p>This handles the boilerplate of writing a lens for each field. It also does
something slightly sneaky: it exposes the generated lenses through the type
itself, as associated constants. What this means is that if you want to use the
lens that gives you the <code>completed</code> field, you can access it via
<code>TodoItem::completed</code>. The generated code basically looks something like:</p>
<pre><code class="language-rust noplaypen">struct GeneratedLens_AppData_title;
struct GeneratedLens_AppData_completed;
struct GeneratedLens_AppData_urgent;

impl TodoItem {
    const title = GeneratedLens_AppData_title;
    const completed = GeneratedLens_AppData_completed;
    const urgent = GeneratedLens_AppData_urgent;
}
</code></pre>
<p>One consequence of this is that if your type has a method with the same name as
one of its fields, <code>derive</code> will fail. To get around this, you can specify a
custom name for a field's lens:</p>
<pre><code class="language-rust noplaypen">#[derive(Lens)]
struct Item {
    #[lens(name = &quot;count_lens&quot;)]
    count: usize,
}

// this now works
impl Item {
    fn count(&amp;self) -&gt; usize {
        self.count
    }
}
</code></pre>
<h2><a class="header" href="#using-lenses" id="using-lenses">Using lenses</a></h2>
<p>The easiest way to use a lens is with the <code>lens</code> method that is provided through
the <code>WigetExt</code> trait; this is a convenient way to wrap a widget in a <code>LensWrap</code>
with a given lens.</p>
<p>Let's build the UI for our todo list item:</p>
<pre><code class="language-rust noplaypen">use druid::widget::{Checkbox, Flex, Label, Widget, WidgetExt};

fn make_todo_item() -&gt; impl Widget&lt;TodoItem&gt; {
    // A label that generates its text based on the data
    let title = Label::dynamic(|text: &amp;String, _| text.to_string()).lens(TodoItem::title);
    let completed = Checkbox::new(&quot;Completed:&quot;).lens(TodoItem::completed);
    let urgent = Checkbox::new(&quot;Urgent:&quot;).lens(TodoItem::urgent);

    Flex::column()
        // label on top
        .with_child(title)
        // two checkboxes below
        .with_child(Flex::row().with_child(completed).with_child(urgent))
}
</code></pre>
<h2><a class="header" href="#advanced-lenses" id="advanced-lenses">Advanced lenses</a></h2>
<p>Field access is a very simple (and common, and <em>useful</em>) case, but lenses can do much more than that.</p>
<h3><a class="header" href="#lensext-and-combinators" id="lensext-and-combinators"><code>LensExt</code> and combinators</a></h3>
<p>Similar to the <code>WidgetExt</code> trait, we offer a <code>LensExt</code> trait that provides
various functions for composing lenses. These are similar to the various methods
on iterator; you can <code>map</code> from one lens to another, you can index into a
collection, or you can efficiently access data in an <code>Arc</code> without unnecessary
mutation; see the main crate documentation for more.</p>
<p>As your application gets more complicated, it will become likely that you want
to use fancier sorts of lensing, and <code>map</code> and company can start to get out
of hand; when that happens, you can always implement a lens by hand.</p>
<h3><a class="header" href="#getting-something-from-a-collection" id="getting-something-from-a-collection">Getting something from a collection</a></h3>
<p>Your application is a contact book, and you would like a lens that
focuses on a specific contact. You might write something like this:</p>
<pre><code class="language-rust noplaypen">#[derive(Clone, Data)]
struct Contact {
    // fields
}

type ContactId = u64;

#[derive(Clone, Data)]
struct Contacts {
    inner: Arc&lt;HashMap&lt;ContactId, Contact&gt;&gt;,
}

// Lets write a lens that returns a specific contact based on its id, if it exists.

struct ContactIdLens(ContactId);

impl Lens&lt;Contacts, Option&lt;Contact&gt;&gt; for ContactIdLens {
    fn with&lt;R, F: FnOnce(&amp;Option&lt;Contact&gt;) -&gt; R&gt;(&amp;self, data: &amp;Contacts, f: F) -&gt; R {
        let contact = data.inner.get(&amp;self.0).cloned();
        f(&amp;contact)
    }

    fn with_mut&lt;R, F: FnOnce(&amp;mut Option&lt;Contact&gt;) -&gt; R&gt;(&amp;self, data: &amp;mut Contacts, f: F) -&gt; R {
        // get an immutable copy
        let mut contact = data.inner.get(&amp;self.0).cloned();
        let result = f(&amp;mut contact);
        // only actually mutate the collection if our result is mutated;
        let changed = match (contact.as_ref(), data.inner.get(&amp;self.0)) {
            (Some(one), Some(two)) =&gt; !one.same(two),
            (None, None) =&gt; false,
            _ =&gt; true,
        };
        if changed {
            //if !data.inner.get(&amp;self.0).same(&amp;contact.as_ref()) {
            let contacts = Arc::make_mut(&amp;mut data.inner);
            // if we're none, we were deleted, and remove from the map; else replace
            match contact {
                Some(contact) =&gt; contacts.insert(self.0, contact),
                None =&gt; contacts.remove(&amp;self.0),
            };
        }
        result
    }
}
</code></pre>
<h3><a class="header" href="#doing-a-conversion" id="doing-a-conversion">Doing a conversion</a></h3>
<p>What if you have a distance in miles that you would like to display in
kilometres?</p>
<pre><code class="language-rust noplaypen">struct MilesToKm;

const KM_PER_MILE: f64 = 1.609_344;

impl Lens&lt;f64, f64&gt; for MilesToKm {
    fn with&lt;R, F: FnOnce(&amp;f64) -&gt; R&gt;(&amp;self, data: &amp;f64, f: F) -&gt; R {
        let kms = *data * KM_PER_MILE;
        f(&amp;kms)
    }

    fn with_mut&lt;R, F: FnOnce(&amp;mut f64) -&gt; R&gt;(&amp;self, data: &amp;mut f64, f: F) -&gt; R {
        let mut kms = *data * KM_PER_MILE;
        let kms_2 = kms;
        let result = f(&amp;mut kms);
        // avoid doing the conversion if unchanged, it might be lossy?
        if !kms.same(&amp;kms_2) {
            let miles = kms * KM_PER_MILE.recip();
            *data = miles;
        }
        result
    }
}
</code></pre>
<h1><a class="header" href="#the-env" id="the-env">The <code>Env</code></a></h1>
<p>The <a href="https://docs.rs/druid/0.5.0/druid/struct.Env.html"><code>Env</code></a> represents the environment; it is intended as a way of managing
and accessing state about your specific application, such as color schemes,
localized strings, and other resources.</p>
<p>The <code>Env</code> is created when the application is launched, and is passed down to all
widgets. The <code>Env</code> may be modified at various points in the tree; values in the
environment can be overridden with other values of the same type, but they can
never be removed. If something exists in the <code>Env</code> at a given level of the tree,
it will exist for everything 'below' that level; that is, for all children of that
widget.</p>
<h2><a class="header" href="#keys-values-and-themes" id="keys-values-and-themes"><code>Key</code>s, <code>Value</code>s, and themes</a></h2>
<p>The most prominent role of <code>Env</code> is to store a set of typed keys and values. The
<code>Env</code> can only store a few types of things; these are represented by the
<a href="https://docs.rs/druid/0.5.0/druid/struct.Value.html"><code>Value</code></a> type, which looks like this:</p>
<pre><code class="language-rust noplaypen">pub enum Value {
    Point(Point),
    Size(Size),
    Rect(Rect),
    Color(Color),
    Float(f64),
    Bool(bool),
    UnsignedInt(u64),
    String(String),
}
</code></pre>
<p>The only way to get an item out of the <code>Env</code> is with a <a href="https://docs.rs/druid/0.5.0/druid/struct.Key.html"><code>Key</code></a>. A <a href="https://docs.rs/druid/0.5.0/druid/struct.Key.html"><code>Key</code></a> is
a combination of a string identifier and a type.</p>
<p>You can think of this as strict types, enforced at runtime. This is less scary
than it sounds, assuming the user follows a few simple guidelines. That said, <strong>It is the
programmer's responsibility to ensure that the environment is used correctly</strong>.
The API is aggressive about checking for misuse, and many methods will panic if
anything is amiss. In practice this should be easy to avoid, by following a few
simple guidelines.</p>
<ol>
<li>
<p><strong><code>Key</code>s should be <code>const</code>s with unique names.</strong> If you need to use a custom
key, you should declare it as a <code>const</code>, and give it a unique name. By
convention, you should namespace your keys using something like <a href="https://en.wikipedia.org/wiki/Reverse_domain_name_notation">reverse-DNS</a>
notation, or even just prefixing them with the name of your app.</p>
<pre><code class="language-rust noplaypen">const BAD_NAME: Key&lt;f64&gt; = Key::new(&quot;height&quot;);
const GOOD_NAME: Key&lt;f64&gt; = Key::new(&quot;com.example.my-app.main-view-height&quot;);
</code></pre>
</li>
<li>
<p><strong><code>Key</code>s must always be set before they are used.</strong> In practice this means
that most keys are set when your application launches, using
<a href="https://docs.rs/druid/0.5.0/druid/struct.AppLauncher.html#method.configure_env"><code>AppLauncher::configure_env</code></a>. Once a key has been added to the <code>Env</code>, it
cannot be deleted, although it can be overwritten.</p>
</li>
<li>
<p><strong>Values can only be overwritten by values of the same type.</strong> If you have a
<code>Key&lt;f64&gt;</code>, assuming that key has already been added to the <code>Env</code>, you cannot
replace it with any other type.</p>
</li>
</ol>
<p>Assuming these rules are followed, <code>Env</code> should just work.</p>
<h3><a class="header" href="#keyorvalue" id="keyorvalue">KeyOrValue</a></h3>
<p>Druid includes a <a href="https://docs.rs/druid/0.5.0/druid/enum.KeyOrValue.html"><code>KeyOrValue</code></a> type that is used for setting certain properties
of widgets. This is a type that can be <em>either</em> a concrete instance of some
type, <em>or</em> a <code>Key</code> that can be used to get that type from the <code>Env</code>.</p>
<pre><code class="language-rust noplaypen">const IMPORTANT_LABEL_COLOR: Key&lt;Color&gt; = Key::new(&quot;my-app.important-label-color&quot;);
const RED: Color = Color::rgb8(0xFF, 0, 0);

fn make_labels() {
    let with_value = Label::&lt;()&gt;::new(&quot;Warning!&quot;).with_text_color(RED);
    let with_key = Label::&lt;()&gt;::new(&quot;Warning!&quot;).with_text_color(IMPORTANT_LABEL_COLOR);
}
</code></pre>
<h3><a class="header" href="#envscope" id="envscope">EnvScope</a></h3>
<p>You may override values in the environment for a given widget (and all of its
children) by using the <a href="https://docs.rs/druid/0.5.0/druid/widget/struct.EnvScope.html"><code>EnvScope</code></a> widget. This is easiest when combined with
the <a href="https://docs.rs/druid/0.5.0/druid/trait.WidgetExt.html#method.env_scope"><code>env_scope</code></a> method on <a href="https://docs.rs/druid/0.5.0/druid/trait.WidgetExt.html"><code>WidgetExt</code></a>:</p>
<pre><code class="language-rust noplaypen">fn scoped_label() {
    let my_label = Label::&lt;()&gt;::new(&quot;Warning!&quot;).env_scope(|env, _| {
        env.set(druid::theme::LABEL_COLOR, Color::BLACK);
        env.set(druid::theme::TEXT_SIZE_NORMAL, 18.0);
    });
}
</code></pre>
<h2><a class="header" href="#localization" id="localization">Localization</a></h2>
<p><em>localization is currently half-baked</em></p>
<p>The <code>Env</code> contains the localization resources for the current locale. A
<a href="https://docs.rs/druid/0.5.0/druid/struct.LocalizedString.html"><code>LocalizedString</code></a> can be resolved to a given string in the current locale by
calling its <a href="https://docs.rs/druid/0.5.0/druid/struct.LocalizedString.html#method.resolve"><code>resolve</code></a> method.</p>
<p>In general, you should not need to worry about localization directly. See the
<a href="./localization.html">localization</a> chapter for an overview of localization in druid.</p>
<h1><a class="header" href="#localization-todo" id="localization-todo">Localization (TODO)</a></h1>
<h1><a class="header" href="#command-todo" id="command-todo">Command (TODO)</a></h1>
<h1><a class="header" href="#create-custom-widgets" id="create-custom-widgets">Create custom widgets</a></h1>
<p>The <code>Widget</code> trait is the heart of druid, and in any serious application you
will eventually need to create and use custom <code>Widget</code>s.</p>
<h2><a class="header" href="#painter-and-controller" id="painter-and-controller"><code>Painter</code> and <code>Controller</code></a></h2>
<p>There are two helper widgets in druid that let you customize widget behaviour
without needing to implement the full widget trait: <a href="https://docs.rs/druid/0.5.0/druid/widget/struct.Painter.html"><code>Painter</code></a> and
<a href="https://docs.rs/druid/0.5.0/druid/widget/trait.Controller.html"><code>Controller</code></a>.</p>
<h3><a class="header" href="#painter" id="painter">Painter</a></h3>
<p>The <a href="https://docs.rs/druid/0.5.0/druid/widget/struct.Painter.html"><code>Painter</code></a> widget lets you draw arbitrary custom content, but cannot
respond to events or otherwise contain update logic. Its general use is to
either provide a custom background to some other widget, or to implement
something like an icon or another graphical element that will be contained in
some other widget.</p>
<p>For instance, if we had some color data and we wanted to display it as a swatch
with rounded corners, we could use a <code>Painter</code>:</p>
<pre><code class="language-rust noplaypen">fn make_color_swatch() -&gt; Painter&lt;Color&gt; {
    Painter::new(|ctx: &amp;mut PaintCtx, data: &amp;Color, env: &amp;Env| {
        let bounds = ctx.size().to_rect();
        let rounded = bounds.to_rounded_rect(CORNER_RADIUS);
        ctx.fill(rounded, data);
        ctx.stroke(rounded, &amp;env.get(druid::theme::PRIMARY_DARK), STROKE_WIDTH);
    })
}
</code></pre>
<p><code>Painter</code> uses all the space that is available to it; if you want to give it a
set size, you must pass it explicit contraints, such as by wrapping it in a
<a href="https://docs.rs/druid/0.5.0/druid/widget/struct.SizedBox.html"><code>SizedBox</code></a>:</p>
<pre><code class="language-rust noplaypen">fn sized_swatch() -&gt; impl Widget&lt;Color&gt; {
    SizedBox::new(make_color_swatch()).width(20.0).height(20.0)
}
</code></pre>
<p>One other useful thing about <code>Painter</code> is that it can be used as the background
of a <a href="https://docs.rs/druid/0.5.0/druid/widget/struct.Container.html"><code>Container</code></a> widget. If we wanted to have a label that used our swatch
as a background, we could do:</p>
<pre><code class="language-rust noplaypen">fn background_label() -&gt; impl Widget&lt;Color&gt; {
    Label::dynamic(|color: &amp;Color, _| {
        let (r, g, b, _) = color.as_rgba_u8();
        format!(&quot;#{:X}{:X}{:X}&quot;, r, g, b)
    })
    .background(make_color_swatch())
}
</code></pre>
<p>(This uses the <a href="https://docs.rs/druid/0.5.0/druid/trait.WidgetExt.html#background"><code>background</code></a> method on <a href="https://docs.rs/druid/0.5.0/druid/trait.WidgetExt.html"><code>WidgetExt</code></a> to embed our label in a
container.)</p>
<h3><a class="header" href="#controller" id="controller">Controller</a></h3>
<p>The <a href="https://docs.rs/druid/0.5.0/druid/widget/trait.Controller.html"><code>Controller</code></a> trait is sort of the inverse of <code>Painter</code>; it is a way to
make widgets that handle events, but don't do any layout or drawing. The idea
here is that you can use some <code>Controller</code> type to customize the behaviour of
some set of children.</p>
<p>The <a href="https://docs.rs/druid/0.5.0/druid/widget/trait.Controller.html"><code>Controller</code></a> trait has <code>event</code>, <code>update</code>, and <code>lifecycle</code> methods, just
like <a href="./widget.html"><code>Widget</code></a>; it does not have <code>paint</code> or <code>layout</code> methods. Also unlike
<a href="./widget.html"><code>Widget</code></a>, all of its methods are optional; you can override only the method
that you need.</p>
<p>There's one other difference to the <code>Controller</code> methods; it is explicitly
passed a mutable reference to its child in each method, so that it can modify it
or forward events as needed.</p>
<p>As an arbitrary example, here is how you might use a <code>Controller</code> to make a
textbox fire some action (say doing a search) 300ms after the last keypress:</p>
<pre><code class="language-rust noplaypen">const ACTION: Selector = Selector::new(&quot;hello.textbox-action&quot;);
const DELAY: Duration = Duration::from_millis(300);

struct TextBoxActionController {
    timer: Option&lt;TimerToken&gt;,
}

impl TextBoxActionController {
    pub fn new() -&gt; Self {
        TextBoxActionController { timer: None }
    }
}

impl Controller&lt;String, TextBox&gt; for TextBoxActionController {
    fn event(
        &amp;mut self,
        child: &amp;mut TextBox,
        ctx: &amp;mut EventCtx,
        event: &amp;Event,
        data: &amp;mut String,
        env: &amp;Env,
    ) {
        match event {
            Event::KeyDown(k) if k.key_code == KeyCode::Return =&gt; {
                ctx.submit_command(ACTION, None);
            }
            Event::KeyUp(k) if k.key_code != KeyCode::Return =&gt; {
                self.timer = Some(ctx.request_timer(DELAY));
                child.event(ctx, event, data, env);
            }
            Event::Timer(token) if Some(*token) == self.timer =&gt; {
                ctx.submit_command(ACTION, None);
            }
            _ =&gt; child.event(ctx, event, data, env),
        }
    }
}
</code></pre>
<h2><a class="header" href="#todo" id="todo">todo</a></h2>
<p>v controller, painter</p>
<ul>
<li>how to do layout
<ul>
<li>how constraints work</li>
<li>child widget, set_layout_rect</li>
<li>paint bounds</li>
</ul>
</li>
<li>container widgets</li>
<li>widgetpod &amp; architecture</li>
<li>commands and widgetid</li>
<li>focus / active / hot</li>
<li>request paint &amp; request layout</li>
<li>changing widgets at runtime</li>
</ul>
<h1><a class="header" href="#example-demos" id="example-demos">Example Demos</a></h1>
<p>This page demonstrates each druid example compatible with the WASM platform.</p>
<script type="module" src="init_wasm.js"></script>
<h2><a class="header" href="#anim" id="anim">Anim</a></h2>
<p><canvas id="canvas_anim" style="width: 100%"></canvas></p>
<h2><a class="header" href="#calc" id="calc">Calc</a></h2>
<p><canvas id="canvas_calc" style="width: 100%"></canvas></p>
<h2><a class="header" href="#custom-widget" id="custom-widget">Custom Widget</a></h2>
<p><canvas id="canvas_custom_widget" style="width: 100%"></canvas></p>
<h2><a class="header" href="#either" id="either">Either</a></h2>
<p><canvas id="canvas_either" style="width: 100%"></canvas></p>
<h2><a class="header" href="#ext-event" id="ext-event">Ext Event</a></h2>
<p>Not yet supported by the WASM platform.</p>
<h2><a class="header" href="#flex" id="flex">Flex</a></h2>
<p><canvas id="canvas_flex" style="width: 100%"></canvas></p>
<h2><a class="header" href="#game-of-life" id="game-of-life">Game of Life</a></h2>
<p><canvas id="canvas_game_of_life" style="width: 100%"></canvas></p>
<h2><a class="header" href="#hello" id="hello">Hello</a></h2>
<p><canvas id="canvas_hello" style="width: 100%"></canvas></p>
<h2><a class="header" href="#identity" id="identity">Identity</a></h2>
<p><canvas id="canvas_identity" style="width: 100%"></canvas></p>
<h2><a class="header" href="#image" id="image">Image</a></h2>
<p><canvas id="canvas_image" style="width: 100%"></canvas></p>
<h2><a class="header" href="#layout" id="layout">Layout</a></h2>
<p><canvas id="canvas_layout" style="width: 100%"></canvas></p>
<h2><a class="header" href="#lens" id="lens">Lens</a></h2>
<p><canvas id="canvas_lens" style="width: 100%"></canvas></p>
<h2><a class="header" href="#list" id="list">List</a></h2>
<p><canvas id="canvas_list" style="width: 100%"></canvas></p>
<h2><a class="header" href="#multiwin" id="multiwin">Multiwin</a></h2>
<p><canvas id="canvas_multiwin" style="width: 100%"></canvas></p>
<h2><a class="header" href="#panels" id="panels">Panels</a></h2>
<p><canvas id="canvas_panels" style="width: 100%"></canvas></p>
<h2><a class="header" href="#parse" id="parse">Parse</a></h2>
<p><canvas id="canvas_parse" style="width: 100%"></canvas></p>
<h2><a class="header" href="#scroll-colors" id="scroll-colors">Scroll Colors</a></h2>
<p><canvas id="canvas_scroll_colors" style="width: 100%"></canvas></p>
<h2><a class="header" href="#scroll" id="scroll">Scroll</a></h2>
<p><canvas id="canvas_scroll" style="width: 100%"></canvas></p>
<h2><a class="header" href="#split-demo" id="split-demo">Split Demo</a></h2>
<p><canvas id="canvas_split_demo" style="width: 100%"></canvas></p>
<h2><a class="header" href="#styled-text" id="styled-text">Styled Text</a></h2>
<p><canvas id="canvas_styled_text" style="width: 100%"></canvas></p>
<h2><a class="header" href="#svg" id="svg">SVG</a></h2>
<p>Not yet supported by the WASM platform.</p>
<h2><a class="header" href="#switches" id="switches">Switches</a></h2>
<p><canvas id="canvas_switches" style="width: 100%"></canvas></p>
<h2><a class="header" href="#timer" id="timer">Timer</a></h2>
<p><canvas id="canvas_timer" style="width: 100%"></canvas></p>
<h2><a class="header" href="#view-switcher" id="view-switcher">View Switcher</a></h2>
<p><canvas id="canvas_view_switcher" style="width: 100%"></canvas></p>
<h1><a class="header" href="#more-information" id="more-information">More information</a></h1>
<p>If you want more information about Druid this document contains links more tutorials, blogposts and
youtube videos.</p>
<h2><a class="header" href="#related-projects" id="related-projects">Related projects</a></h2>
<p>These three projects provide the basis that Druid works on</p>
<ul>
<li><a href="https://github.com/linebender/piet">Piet</a> An abstraction for 2D graphics.</li>
<li><a href="https://github.com/linebender/kurbo">Kurbo</a> A Rust library for manipulating curves</li>
<li><a href="https://github.com/linebender/skribo">Skribo</a> A Rust library for low-level text layout</li>
</ul>
<h2><a class="header" href="#projects-using-druid" id="projects-using-druid">Projects using Druid</a></h2>
<ul>
<li><a href="https://github.com/tbillington/kondo">Kondo</a> Save disk space by cleaning unneeded files from software projects.</li>
<li><em>pull requests welcome</em></li>
</ul>
<h2><a class="header" href="#projects-that-work-with-druid-widgets-etc" id="projects-that-work-with-druid-widgets-etc">Projects that work with Druid (widgets etc)</a></h2>
<ul>
<li><em>pull requests welcome</em></li>
</ul>
<h2><a class="header" href="#presentations" id="presentations">Presentations</a></h2>
<p>Some presentations about Druid, its background and related topics have been recorded</p>
<ul>
<li><a href="https://youtu.be/xH2x99FTY4k">Declarative UI patterns in Rust</a> by Raph Levien at the Bay Area Rust Meetup December 3 2019</li>
<li><a href="https://youtu.be/4YTfxresvS8">Data oriented GUI in Rust</a> by Raph Levien at the Bay Area Rust Meetup June 28 2018</li>
</ul>
<h2><a class="header" href="#blog-posts" id="blog-posts">Blog posts</a></h2>
<p>People have been blogging about Druid</p>
<ul>
<li><a href="https://pauljmiller.com/posts/druid-widget-tutorial.html">Building a widget for Druid</a> a blog post by Paul Miller on how to create custom Widgets that explains lots of Druid on the way</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
